# print(PlotLis_ord[[3]], split=c(1, 2, 2, 2), newpage=FALSE)
# print(PlotLis_ord[[4]], split=c(2, 2, 2, 2), newpage=FALSE)
# grid.text("a)", x = .1, y = .945, just = c("left", "bottom"), gp = gpar(cex=2))
# grid.text("b)", x = .6, y = .945, just = c("left", "bottom"), gp = gpar(cex=2))
# grid.text("c)", x = .1, y = .445, just = c("left", "bottom"), gp = gpar(cex=2))
# grid.text("d)", x = .6, y = .445, just = c("left", "bottom"), gp = gpar(cex=2))
# dev.off()
#
# c(PlotLis_ord[[1]],PlotLis_ord[[2]],PlotLis_ord[[3]],PlotLis_ord[[4]],layout=2:2)
# p1 = levelplot(p.nA.xtab)
# p2 = levelplot(p.nA.xtab)
# p3 = levelplot(p.nA.xtab)
# p4 = levelplot(p.nA.xtab)
# c(p1,p2,p3,p4,layout=2:2)
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
# Chunk 2: source_files
require(dunn.test)
require(lattice)
require(grid)
require(reshape2)
require(RColorBrewer)
require(ggplot2)
RoughPath = '//files.geo.uzh.ch/shared/group/h2k-data/Projects/CrowdWater/WP1.5-WaterLevelClasses/Data/Results/'
ScriptPath = '//files.geo.uzh.ch/shared/group/h2k-data/Projects/CrowdWater/WP1.5-WaterLevelClasses/R_Scripts/'
source(paste0(ScriptPath,'helpfunctions.R'))
# invisible(source(paste0(ScriptPath,'7 - readInResultTextFiles.R')))
# CrossValidTab = read.csv(paste0(RoughPath,'CrossValidationResults.csv'),stringsAsFactors = F)
CrossValidTab_Medians = read.csv(paste0(RoughPath,'CrossValidationResults_MedianswithDaily.csv'),stringsAsFactors = F)
# reorder the random ones in the same order as all the others
CrossValidTab_Medians$orderString = unlist(lapply(strsplit(CrossValidTab_Medians$CatchmentModelType,'_'),function(x) paste0(x[[1]],'_',x[[2]],'_',x[[3]],'_',x[[4]])))
#Statgroup including catchments
# print performances of streamflow no error hourly datasets
noErrHourly = CrossValidTab_Medians[CrossValidTab_Medians$TempRes=='hourly' & CrossValidTab_Medians$NoiseType == 'noError' & CrossValidTab_Medians$Class == 'Streamflow',]
print('POAs of all bench-hourly validations')
print(summary(noErrHourly$POA))
BADRunoffRainfallRatios = data.frame(catchment = c(rep('Allenbach',9),rep('RialediCalneggia',9),rep('Verzasca',6)),yearCharacters = c(unique(c('dryCalBymean','dryCalBywet','dryCalBydry','meanCalBymean','meanCalBywet','meanCalBydry','wetCalBymean','wetCalBydry','wetCalBywet')),
unique(c('dryCalBymean','dryCalBywet','dryCalBydry','meanCalBymean','meanCalBywet','meanCalBydry','wetCalBymean','wetCalBydry','wetCalBywet')),
unique(c('dryCalBywet','meanCalBywet','wetCalBywet')),unique(c('dryCalBydry','meanCalBydry','wetCalBydry'))))
##################################################################################
noErrHourly$catchment = sapply(strsplit(noErrHourly$CatchmentModelType,'_'),'[[',2)
# remove the ones with a bad QP-ratio
for(i in seq_along(BADRunoffRainfallRatios[,1])){
noErrHourly = noErrHourly[-which(noErrHourly$catchment==BADRunoffRainfallRatios$catchment[i] & noErrHourly$yearChar==BADRunoffRainfallRatios$yearCharacters[i]),]
}
print('POAs of all bench-hourly validations with good QP-ratios')
print(round(summary(noErrHourly$POA),2))
uq.catchment = unique(noErrHourly$catchment)
uq.yearchar = unique(noErrHourly$yearChar)
# median POAs of all catchments and year characters
for(i in seq_along(uq.catchment)){
t.catchdatAllYC = noErrHourly[noErrHourly$catchment==uq.catchment[i] & noErrHourly$Class=='Streamflow',]
print(paste0(uq.catchment[i],' Median Streamflow POA - ',median(t.catchdatAllYC$POA)))
for(j in seq_along(uq.yearchar)){
t.yearcharmedian = t.catchdatAllYC[t.catchdatAllYC$yearChar==uq.yearchar[j],]
#
print(paste0(uq.catchment[i],' ',uq.yearchar[j], ' Streamflow median POA - ',t.yearcharmedian$POA))
}
}
##################################################################################
# print median validation results of for the models calibrated using hourly stream level data
noErrHourlyWL = CrossValidTab_Medians[CrossValidTab_Medians$TempRes=='hourly' & CrossValidTab_Medians$NoiseType == 'noError' & CrossValidTab_Medians$Class == 'waterlevels',]
noErrHourlyWL$catchment = sapply(strsplit(noErrHourlyWL$CatchmentModelType,'_'),'[[',2)
# remove bad PQ ratios
for(i in seq_along(BADRunoffRainfallRatios[,1])){
noErrHourlyWL = noErrHourlyWL[-which(noErrHourlyWL$catchment==BADRunoffRainfallRatios$catchment[i] & noErrHourlyWL$yearChar==BADRunoffRainfallRatios$yearCharacters[i]),]
}
print('POAs of all hourly continous Waterlevels validations with good QP-ratios')
print(round(summary(noErrHourlyWL$POA),2))
# do a paired mann whitney u-test between those hourly no error calibrations using continuous waterlevels and continous streamflow
noErrHourlySF_WL = rbind(noErrHourly,noErrHourlyWL)
wilcox.test(noErrHourly$POA,noErrHourlyWL$POA, conf.int=T, conf.level=0.95, paired=T,alternative = 'greater') # greater= no error hourly streamflow is better than no error, hourly waterlevels if p<0.05
##################################################################################
# print median validation results of for the models calibrated using hourly water level class data
noErrHourlyWLC = CrossValidTab_Medians[CrossValidTab_Medians$TempRes=='hourly' & CrossValidTab_Medians$NoiseType == 'noError' & grepl('Classes',CrossValidTab_Medians$Class),]
noErrHourlyWLC$catchment = sapply(strsplit(noErrHourlyWLC$CatchmentModelType,'_'),'[[',2)
# remove bad PQ ratios
for(i in seq_along(BADRunoffRainfallRatios[,1])){
noErrHourlyWLC = noErrHourlyWLC[-which(noErrHourlyWLC$catchment==BADRunoffRainfallRatios$catchment[i] & noErrHourlyWLC$yearChar==BADRunoffRainfallRatios$yearCharacters[i]),]
}
print('POAs of all bench-hourly Waterlevel classes validations with good QP-ratios')
print(round(summary(noErrHourlyWLC$POA),2))
# # do a paired wilcoxon u-test between those hourly no error calibrations using hourly waterlevel classes and continous streamflow
# noErrHourlySF_WL = rbind(noErrHourly,noErrHourlyWLC)
# wilcox.test(noErrHourly$POA,noErrHourlyWLC$POA, conf.int=T, conf.level=0.95, paired=F,alternative = 'greater')
# ---> above test does not make sense, see results for individual classes
##################################################################################
# compare all hourly stream level and water level classes ---> does not make sense
# print('Comparison of all hourly streamlevels with all hourly water level classes')
# paired wilcox test (one sided) with classes --> see further below WLC vs WL
# non-paired mann whitney u-test with all WL-Classes vs. water levels.
# wilcox.test(noErrHourlyWL$POA,noErrHourlyWLC$POA, conf.int=T, conf.level=0.95, paired=F,alternative = 'greater')
# Chunk 3: Mann Whitney U-Test
# CrossValidTab_Medians = CrossValidTab_Medians[!grepl('Allenbach',CrossValidTab_Medians$CatchmentModelType),] # to exclude Allenbach
st.uq.statGroup = unique(CrossValidTab_Medians$statGroup)
# modelNameSplits = strsplit(CrossValidTab$CatchmentModelType,'_')
# st.uq.statGroup = unique(paste0(sapply(modelNameSplits,'[',5),'_',sapply(modelNameSplits,'[',6),'_',sapply(modelNameSplits,'[',7)))
# remove the random ones
st.uq.statGroup = st.uq.statGroup[!st.uq.statGroup=='random_random_random']
TotalMeanCrossValMWPvalTab = data.frame(ModelType = st.uq.statGroup,pvals = NA)
resList = list()
for (i in seq_along(st.uq.statGroup)){
statGrp = CrossValidTab_Medians[CrossValidTab_Medians$statGroup == st.uq.statGroup[i],]
randGrp = CrossValidTab_Medians[CrossValidTab_Medians$statGroup == 'random_random_random',]
# order the values to allow a paired test
if(identical(sort(randGrp$orderString),statGrp$orderString)){
randGrp_ord = randGrp[order(randGrp$orderString),]
# identical(randGrp_ord$orderString,statGrp$orderString)
}else stop()
resList[[i]] = wilcox.test(statGrp$rel2bench,randGrp_ord$rel2bench,mu=0, conf.int=T, conf.level=0.95, paired=T, exact =T,alternative = 'greater')
print(paste0(st.uq.statGroup[i],': p.value = ',round(resList[[i]]$p.value,3)))
TotalMeanCrossValMWPvalTab$pvals[i] = round(resList[[i]]$p.value,3)
}
TotalMeanCrossValMWPvalTab$ModelType = gsub('hourly','Hourly',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('weekly','Weekly',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('JAS2ndDay','IntenseSummer',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('MarAugSatSun','WeekendSpring',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('MayOctSatSun','WeekendSummer',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('CWTempRes52','Crowd52',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('CWTempRes12','Crowd12',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('monthly','Monthly',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('Daily','Daily',TotalMeanCrossValMWPvalTab$ModelType)
write.table(TotalMeanCrossValMWPvalTab,file=paste0(RoughPath,'TotalMeanCrossValMannWhitneyPvalTabWithDaily.txt'),sep=',')
# Chunk 4: Mann Whitney U-Test no Bad QP ratio vs random
# CrossValidTab_Medians = CrossValidTab_Medians[!grepl('Allenbach',CrossValidTab_Medians$CatchmentModelType),] # to exclude Allenbach
modelNameSplits = strsplit(CrossValidTab_Medians$CatchmentModelType,'_')
CrossValidTab_Medians$catchments = sapply(modelNameSplits,'[[',2)
CrossValidTab_Medians2p0 = CrossValidTab_Medians
for(i in seq_along(BADRunoffRainfallRatios[,1])){
idx.out = which((CrossValidTab_Medians2p0$catchment==as.character(BADRunoffRainfallRatios$catchment[i])) & (CrossValidTab_Medians2p0$yearChar==as.character(BADRunoffRainfallRatios$yearCharacters[i])))
CrossValidTab_Medians2p0= CrossValidTab_Medians2p0[-idx.out,]
print(paste0(i,' length Tab = ',nrow(CrossValidTab_Medians2p0)))
}
# print performances of streamflow no error hourly datasets
noErrHourly = CrossValidTab_Medians2p0[CrossValidTab_Medians2p0$TempRes=='hourly' & CrossValidTab_Medians2p0$NoiseType == 'noError' & CrossValidTab_Medians2p0$Class == 'Streamflow',]
print('POAs of all bench-hourly validations')
print(summary(noErrHourly$POA))
st.uq.statGroup = unique(CrossValidTab_Medians2p0$statGroup)
# remove the random ones
st.uq.statGroup = st.uq.statGroup[!st.uq.statGroup=='random_random_random']
TotalMeanCrossValMWPvalTab = data.frame(ModelType = st.uq.statGroup,pvals = NA,meanBench=NA,medianBench=NA,meanScen=NA,medianScen=NA)
resList = list()
for (i in seq_along(st.uq.statGroup)){
tab_temp = CrossValidTab_Medians2p0[CrossValidTab_Medians2p0$statGroup == st.uq.statGroup[i],]
tab_LoBench = CrossValidTab_Medians2p0[CrossValidTab_Medians2p0$statGroup == "random_random_random",]
# make sure the two tables (upper benchmark - streamflow and the data subset) are in the same order
tab_LoBench_ord = as.data.frame(matrix(data=NA,ncol=ncol(tab_LoBench),nrow = nrow(tab_LoBench)))
colnames(tab_LoBench_ord) = colnames(tab_LoBench)
for(j in seq_along(tab_LoBench_ord$orderString)){
tab_LoBench_ord[j,] = tab_LoBench[tab_LoBench$orderString==tab_temp$orderString[j],]
}
#test if ordered correctly
if(!identical(tab_temp$orderString,tab_LoBench_ord$orderString)){stop()}
resList[[i]] = wilcox.test(tab_temp$POA,tab_LoBench_ord$POA, conf.int=T, conf.level=0.95, paired=T, exact =T,mu=0,alternative = 'greater')
print(paste0(st.uq.statGroup[i],': p.value = ',round(resList[[i]]$p.value,3)))
TotalMeanCrossValMWPvalTab$pvals[i] = round(resList[[i]]$p.value,3)
TotalMeanCrossValMWPvalTab$meanBench[i] = mean(tab_LoBench_ord$POA,na.rm = T)
TotalMeanCrossValMWPvalTab$medianBench[i] = median(tab_LoBench_ord$POA,na.rm = T)
TotalMeanCrossValMWPvalTab$meanScen[i] = mean(tab_temp$POA,na.rm = T)
TotalMeanCrossValMWPvalTab$medianScen[i] = median(tab_temp$POA,na.rm = T)
}
TotalMeanCrossValMWPvalTab$ModelType = gsub('hourly','Hourly',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('weekly','Weekly',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('JAS2ndDay','IntenseSummer',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('MarAugSatSun','WeekendSpring',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('MayOctSatSun','WeekendSummer',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('CWTempRes52','Crowd52',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('CWTempRes12','Crowd12',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('monthly','Monthly',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('Daily','Daily',TotalMeanCrossValMWPvalTab$ModelType)
write.table(TotalMeanCrossValMWPvalTab,file=paste0(RoughPath,'TotalMeanCrossValMannWhitneyPvalTabWithDaily_NoBadQP_relations.txt'),sep=',')
# Chunk 5: Mann Whitney U-Test no Bad QP ratio streamflow with streamlevel
# CrossValidTab_Medians = CrossValidTab_Medians[!grepl('Allenbach',CrossValidTab_Medians$CatchmentModelType),] # to exclude Allenbach
modelNameSplits = strsplit(CrossValidTab_Medians$CatchmentModelType,'_')
CrossValidTab_Medians$catchments = sapply(modelNameSplits,'[[',2)
CrossValidTab_Medians2p0 = CrossValidTab_Medians
for(i in seq_along(BADRunoffRainfallRatios[,1])){
idx.out = which((CrossValidTab_Medians2p0$catchment==as.character(BADRunoffRainfallRatios$catchment[i])) & (CrossValidTab_Medians2p0$yearChar==as.character(BADRunoffRainfallRatios$yearCharacters[i])))
CrossValidTab_Medians2p0= CrossValidTab_Medians2p0[-idx.out,]
print(paste0(i,' length Tab = ',nrow(CrossValidTab_Medians2p0)))
}
st.uq.statGroup = unique(CrossValidTab_Medians2p0$statGroup)
############ comparison against streamflow with a paired wilcox.test()
st.uq.statGroupnoSF = st.uq.statGroup[!st.uq.statGroup=="noError_hourly_Streamflow"]
TotalMeanCrossValMWPvalTab = data.frame(ModelType = st.uq.statGroupnoSF,pvals = NA,meanBench=NA,medianBench=NA,meanScen=NA,medianScen=NA)
resListSF = list()
for (i in seq_along(st.uq.statGroupnoSF)){
tab_temp = CrossValidTab_Medians2p0[CrossValidTab_Medians2p0$statGroup == st.uq.statGroupnoSF[i],]
tab_upBench = CrossValidTab_Medians2p0[CrossValidTab_Medians2p0$statGroup == "noError_hourly_Streamflow",]
# make sure the two tables (upper benchmark - streamflow and the data subset) are in the same order
tab_temp_ord = as.data.frame(matrix(data=NA,ncol=ncol(tab_temp),nrow = nrow(tab_temp)))
colnames(tab_temp_ord) = colnames(tab_temp)
for(j in seq_along(tab_upBench$orderString)){
tab_temp_ord[j,] = tab_temp[tab_temp$orderString==tab_upBench$orderString[j],]
}
#test if ordered correctly
stopifnot(identical(tab_temp_ord$orderString,tab_upBench$orderString))
resListSF[[i]] = wilcox.test(tab_temp_ord$POA,tab_upBench$POA, conf.int=T, conf.level=0.95, paired=T, exact =T,mu=0,alternative = 'less')
print(paste0(st.uq.statGroupnoSF[i],': p.value = ',round(resListSF[[i]]$p.value,3)))
TotalMeanCrossValMWPvalTab$pvals[i] = round(resListSF[[i]]$p.value,3)
TotalMeanCrossValMWPvalTab$meanBench[i] = mean(tab_upBench$POA,na.rm = T)
TotalMeanCrossValMWPvalTab$medianBench[i] = median(tab_upBench$POA,na.rm = T)
TotalMeanCrossValMWPvalTab$meanScen[i] = mean(tab_temp_ord$POA,na.rm = T)
TotalMeanCrossValMWPvalTab$medianScen[i] = median(tab_temp_ord$POA,na.rm = T)
}
TotalMeanCrossValMWPvalTab$ModelType = gsub('hourly','Hourly',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('weekly','Weekly',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('JAS2ndDay','IntenseSummer',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('MarAugSatSun','WeekendSpring',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('MayOctSatSun','WeekendSummer',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('CWTempRes52','Crowd52',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('CWTempRes12','Crowd12',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('monthly','Monthly',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('Daily','Daily',TotalMeanCrossValMWPvalTab$ModelType)
write.table(TotalMeanCrossValMWPvalTab,file=paste0(RoughPath,'TotalMeanCrossValMannWhitneyPvalTabWithDaily_NoBadQP_vs_streamflow.txt'),sep=',')
#############################################################################################
# comparison against continous waterlevels with a paired, one sided wilcox.test()
st.uq.statGroupnoWL = st.uq.statGroup[!st.uq.statGroup=="noError_hourly_waterlevels"]
TotalMeanCrossValMWPvalTab = data.frame(ModelType = st.uq.statGroupnoWL,pvals = NA,meanBench=NA,medianBench=NA,meanScen=NA,medianScen=NA)
resListWL = list()
for (i in seq_along(st.uq.statGroupnoWL)){
tab_temp = CrossValidTab_Medians2p0[CrossValidTab_Medians2p0$statGroup == st.uq.statGroupnoWL[i],]
tab_upBench = CrossValidTab_Medians2p0[CrossValidTab_Medians2p0$statGroup =="noError_hourly_waterlevels",]
# make sure the two tables (upper benchmark - streamflow and the data subset) are in the same order
tab_temp_ord = as.data.frame(matrix(data=NA,ncol=ncol(tab_temp),nrow = nrow(tab_temp)))
colnames(tab_temp_ord) = colnames(tab_temp)
for(j in seq_along(tab_upBench$orderString)){
tab_temp_ord[j,] = tab_temp[tab_temp$orderString==tab_upBench$orderString[j],]
}
stopifnot(identical(tab_temp_ord$orderString,tab_upBench$orderString))
resListWL[[i]] = wilcox.test(tab_temp_ord$POA,tab_upBench$POA, conf.int=T, conf.level=0.95, paired=T, exact =T,mu=0,alternative = 'less')
print(paste0(st.uq.statGroupnoWL[i],': p.value = ',round(resListWL[[i]]$p.value,3)))
TotalMeanCrossValMWPvalTab$pvals[i] = round(resListWL[[i]]$p.value,3)
TotalMeanCrossValMWPvalTab$meanBench[i] = mean(tab_upBench$POA,na.rm = T)
TotalMeanCrossValMWPvalTab$medianBench[i] = median(tab_upBench$POA,na.rm = T)
TotalMeanCrossValMWPvalTab$meanScen[i] = mean(tab_temp_ord$POA,na.rm = T)
TotalMeanCrossValMWPvalTab$medianScen[i] = median(tab_temp_ord$POA,na.rm = T)
}
# rename to new names
TotalMeanCrossValMWPvalTab$ModelType = gsub('hourly','Hourly',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('weekly','Weekly',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('JAS2ndDay','IntenseSummer',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('MarAugSatSun','WeekendSpring',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('MayOctSatSun','WeekendSummer',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('CWTempRes52','Crowd52',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('CWTempRes12','Crowd12',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('monthly','Monthly',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('Daily','Daily',TotalMeanCrossValMWPvalTab$ModelType)
write.table(TotalMeanCrossValMWPvalTab,file=paste0(RoughPath,'TotalMeanCrossValMannWhitneyPvalTabWithDaily_NoBadQP_vs_streamlevel.txt'),sep=',')
######## comparison against waterlevels of the same class with a paired wilcox.test()
st.uq.statGroupsnoWL = st.uq.statGroup[!grepl('waterlevels',st.uq.statGroup)]
st.uq.statGroupsWL = st.uq.statGroup[grepl('waterlevels',st.uq.statGroup)]
TotalMeanCrossValMWPvalTab = data.frame(ModelType = 1:127,pvals = NA,meanBench=NA,medianBench=NA,meanScen=NA,medianScen=NA)
resListWL = list()
resListWLidx = 1
for (i in seq_along(st.uq.statGroupsWL)){
TempResWL = paste0(unlist(strsplit(st.uq.statGroupsWL[i],'_'))[2],collapse = '_')
subsToCompWL = st.uq.statGroupsnoWL[grepl(TempResWL,st.uq.statGroupsnoWL)]
for(j in seq_along(subsToCompWL)){
tab_WLbench = CrossValidTab_Medians2p0[CrossValidTab_Medians2p0$statGroup == st.uq.statGroupsWL[i],]
tab_WLtemp = CrossValidTab_Medians2p0[CrossValidTab_Medians2p0$statGroup == subsToCompWL[j],]
# make sure the two tables are in the same order
tab_WLtemp_ord = as.data.frame(matrix(data=NA,ncol=ncol(tab_WLtemp),nrow = nrow(tab_WLtemp)))
colnames(tab_WLtemp_ord) = colnames(tab_WLtemp)
for(jj in seq_along(tab_WLbench$orderString)){
tab_WLtemp_ord[jj,] = tab_WLtemp[tab_WLtemp$orderString==tab_WLbench$orderString[jj],]
}
stopifnot(identical(tab_WLtemp_ord$orderString,tab_WLbench$orderString))
resListWL[[resListWLidx]] = wilcox.test(tab_WLtemp_ord$POA,tab_WLbench$POA,mu=0, conf.int=T, conf.level=0.95, paired=T, exact =F,alternative = 'less')
print(paste0(st.uq.statGroupsWL[i],' vs. ',subsToCompWL[j],': p.value = ',round(resListWL[[resListWLidx]]$p.value,3)))
TotalMeanCrossValMWPvalTab$ModelType[resListWLidx] = paste0(st.uq.statGroupsWL[i],' vs. ',subsToCompWL[j])
TotalMeanCrossValMWPvalTab$pvals[resListWLidx] = round(resListWL[[resListWLidx]]$p.value,3)
TotalMeanCrossValMWPvalTab$meanBench[resListWLidx] = mean(tab_WLbench$POA,na.rm = T)
TotalMeanCrossValMWPvalTab$medianBench[resListWLidx] = median(tab_WLbench$POA,na.rm = T)
TotalMeanCrossValMWPvalTab$meanScen[resListWLidx] = mean(tab_WLtemp_ord$POA,na.rm = T)
TotalMeanCrossValMWPvalTab$medianScen[resListWLidx] = median(tab_WLtemp_ord$POA,na.rm = T)
resListWLidx = resListWLidx +1
}
}
TotalMeanCrossValMWPvalTab$ModelType = gsub('hourly','Hourly',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('weekly','Weekly',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('JAS2ndDay','IntenseSummer',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('MarAugSatSun','WeekendSpring',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('MayOctSatSun','WeekendSummer',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('CWTempRes52','Crowd52',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('CWTempRes12','Crowd12',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('monthly','Monthly',TotalMeanCrossValMWPvalTab$ModelType)
TotalMeanCrossValMWPvalTab$ModelType = gsub('Daily','Daily',TotalMeanCrossValMWPvalTab$ModelType)
write.table(TotalMeanCrossValMWPvalTab,file=paste0(RoughPath,'TotalMeanCrossValMannWhitneyPvalTabWithDaily_NoBadQP_vs_ClassWiseWaterlevel.txt'),sep=',')
uq.yearchar = unique(CrossValidTab_Medians2p0$yearChar)
CrossValMWPvalTab = as.data.frame(matrix(data=NA, ncol = length(uq.yearchar),nrow = length(st.uq.statGroup)))
colnames(CrossValMWPvalTab) = uq.yearchar
row.names(CrossValMWPvalTab) = st.uq.statGroup
for(j in seq_along(uq.yearchar)){
valYearChar = strsplit(uq.yearchar[j],'CalBy')[[1]][1]
calYearChar = strsplit(uq.yearchar[j],'CalBy')[[1]][2]
t.yc.CrossValidTab = CrossValidTab_Medians2p0[CrossValidTab_Medians2p0$yearChar==uq.yearchar[j] & CrossValidTab_Medians2p0$statGroup!='random_random_random',]
t.yc_Rand4CrossValTab = CrossValidTab_Medians2p0[CrossValidTab_Medians2p0$yearChar==paste0(valYearChar,'CalBy',calYearChar) & CrossValidTab_Medians2p0$statGroup == 'random_random_random',]
t.yc.CrossValidTab_withRandom = rbind(t.yc.CrossValidTab,t.yc_Rand4CrossValTab)
resList = list()
print(uq.yearchar[j])
for (i in seq_along(st.uq.statGroup)){
if(st.uq.statGroup[i] == 'random_random_random')next()
tab_lowBench = t.yc.CrossValidTab_withRandom[t.yc.CrossValidTab_withRandom$statGroup == 'random_random_random',]
tab_yearDat = t.yc.CrossValidTab_withRandom[t.yc.CrossValidTab_withRandom$statGroup == st.uq.statGroup[i],]
tab_lowBench_ord = as.data.frame(matrix(data=NA, ncol=ncol(tab_yearDat),nrow=nrow(tab_yearDat)))
colnames(tab_lowBench_ord) = colnames(tab_yearDat)
for(jj in seq_along(tab_yearDat$orderString)){
tab_lowBench_ord[jj,] = tab_lowBench[tab_lowBench$orderString==tab_yearDat$orderString[jj],]
}
resList[[i]] = wilcox.test(tab_yearDat$POA,tab_lowBench_ord$POA,mu=0, conf.int=T, conf.level=0.95, paired=T, exact =T,alternative = 'greater')
print(paste0(st.uq.statGroup[i],': p.value = ',round(resList[[i]]$p.value,3)))
CrossValMWPvalTab[i,j] = round(resList[[i]]$p.value,3)
}
}
# levelplot(as.matrix(CrossValMWPvalTab),scales=list(x=list(rot=45,cex=.75,draw=T)))
write.table(CrossValMWPvalTab,file=paste0(RoughPath,'CrossValMannWhitneyPvalTab_byYearChar.txt'),sep=',')
warnings()
resListDBt = list()
PlotList = list()
tab4Plotlist = list()
st.uq.quality4plot = c('no error','large error','medium error','small error')
letter4plot = c('a)','d)','c)','b)')
for (i in seq_along(st.uq.quality)){
for(j in seq_along(st.uq.class)){
if(st.uq.class[j]=="Streamflow" || st.uq.class[j] =="random"|| (st.uq.class[j] !='10ClassesCER' && is.element(st.uq.quality[i],c('SDdivBy1','SDdivBy2','SDdivBy4'))))next
stat.DBtestTab = CrossValidTab_Medians2p0[CrossValidTab_Medians2p0$NoiseType == st.uq.quality[i] & CrossValidTab_Medians2p0$Class == st.uq.class[j],]
stat.DBtestTab$TempRes = as.factor(stat.DBtestTab$TempRes)
x = stat.DBtestTab$rel2bench
y = stat.DBtestTab$TempRes
resListDBt[[i]]=dunn.test(x,y,kw=F,method = 'bonferroni',table = F, list=F,alpha=0.1)
# resListDBt[[i]]=dunn.test(x,y,kw=F,method = 'none') -> without adjusted p-values
# assessment of the strength of the effect
n = length(unique(y))
effectStrength = abs(resListDBt[[i]]$Z/sqrt(n))
print(paste0(st.uq.quality[i],' Group: D-B p.values'))
comparisons = t(as.data.frame(strsplit(resListDBt[[i]]$comparisons,' - ')))
resTab = as.data.frame(cbind(unname(comparisons),resListDBt[[i]]$P,resListDBt[[i]]$P.adjusted,effectStrength))
colnames(resTab)<- c('Comparison1','Comparison2','p-values','Adj.p-values','StrengthOfEffect')
idxs = order(resTab$`p-values`)
resTab = resTab[idxs,]
print(resTab)
p.nA.xtab = as.matrix(xtabs(as.numeric(as.character(resTab$`p-values`))~resTab$Comparison1+resTab$Comparison2))
p.Adj.xtab = as.matrix(xtabs(as.numeric(as.character(resTab$`Adj.p-values`))~resTab$Comparison1+resTab$Comparison2))
# reorder p.nA.xtab & p.Adj.xtab
newOrder = c('hourly','Daily','weekly','CWTempRes52','monthly','CWTempRes12','MarAugSatSun','MayOctSatSun','JAS2ndDay')
new.p.Adj.xtab = matrix(nrow = nrow(p.Adj.xtab),ncol = ncol(p.Adj.xtab))
colnames(new.p.Adj.xtab) = newOrder[2:length(newOrder)]
row.names(new.p.Adj.xtab) = newOrder[1:length(newOrder)-1]
p.Adj.xtab[p.Adj.xtab==0]<- NA
p.nA.xtab[p.nA.xtab==0]<- NA
n.cnames.adj = colnames(new.p.Adj.xtab)
n.rnames.adj = row.names(new.p.Adj.xtab)
meltedOldTab = melt(p.Adj.xtab)
meltedOldTab = meltedOldTab[!is.na(meltedOldTab$value),]
for(c in seq_along(n.cnames.adj)){
for(r in seq_along(n.rnames.adj)){
if(n.cnames.adj[c] == n.rnames.adj[r]){
next
}else{
valfromOldTab = meltedOldTab$value[xor((meltedOldTab$`resTab$Comparison1`== n.cnames.adj[c] & meltedOldTab$`resTab$Comparison2`== n.rnames.adj[r]),(meltedOldTab$`resTab$Comparison2`== n.cnames.adj[c] & meltedOldTab$`resTab$Comparison1`== n.rnames.adj[r]))]
new.p.Adj.xtab[r,c] = valfromOldTab
}
}
}
# remove the obsolete values
for(c in seq_along(n.cnames.adj)){
if(length(which(is.na(new.p.Adj.xtab[,c])))>0){
new.p.Adj.xtab[which(is.na(new.p.Adj.xtab[,c])):ncol(new.p.Adj.xtab),c] = NA
}
}
new.p.nA.xtab = matrix(nrow = nrow(p.nA.xtab),ncol = ncol(p.nA.xtab))
colnames(new.p.nA.xtab) = newOrder[2:length(newOrder)]
row.names(new.p.nA.xtab) = newOrder[1:length(newOrder)-1]
n.cnames.adj = colnames(new.p.nA.xtab)
n.rnames.adj = row.names(new.p.nA.xtab)
meltedOldTab = melt(p.nA.xtab)
meltedOldTab = meltedOldTab[!is.na(meltedOldTab$value),]
for(c in seq_along(n.cnames.adj)){
for(r in seq_along(n.rnames.adj)){
if(n.cnames.adj[c] == n.rnames.adj[r]){
next
}else{
valfromOldTab = meltedOldTab$value[xor((meltedOldTab$`resTab$Comparison1`== n.cnames.adj[c] & meltedOldTab$`resTab$Comparison2`== n.rnames.adj[r]),(meltedOldTab$`resTab$Comparison2`== n.cnames.adj[c] & meltedOldTab$`resTab$Comparison1`== n.rnames.adj[r]))]
new.p.nA.xtab[r,c] = valfromOldTab
}
}
}
# remove the obsolete values
for(c in seq_along(n.cnames.adj)){
if(length(which(is.na(new.p.nA.xtab[,c])))>0){
new.p.nA.xtab[which(is.na(new.p.nA.xtab[,c])):ncol(new.p.nA.xtab),c] = NA
}
}
# colors <- colorRampPalette(c("cornsilk","cornsilk4"))(length(seq(0.05,1,by=0.05)))
colors <- crameriPalette("oslo",length(seq(0.05,1,by=0.05)))
pointFill = "#FFFFFF"
starIdx = as.data.frame(which(new.p.Adj.xtab<=0.05,arr.ind = T))
starIdx_nA = as.data.frame(which(new.p.nA.xtab<=0.05,arr.ind = T))
p_symbol = 24
p_adj_symbol =25
# insert the new names
row.names(new.p.nA.xtab) = c('Hourly','Daily','Weekly','Crowd52','Monthly','Crowd12','WeekendSpring','WeekendSummer')
colnames(new.p.nA.xtab) = c('Daily','Weekly','Crowd52','Monthly','Crowd12','WeekendSpring','WeekendSummer','IntenseSummer')
setEPS()
postscript(paste0('//files.geo.uzh.ch/shared/group/h2k-data/Projects/CrowdWater/WP1.5-WaterLevelClasses/Paper/Figures/BonferroniHeatMaps/CrossValBonferroniHeatMap_',st.uq.quality[i],'_',st.uq.class[j],'.eps'),width = 7,height = 7)
# print(levelplot(new.p.nA.xtab,xlab ='', ylab='',aspect='iso',col.regions=colors,main = st.uq.quality4plot[i],
print(
levelplot(new.p.nA.xtab,xlab ='', ylab='',aspect='iso',col.regions=colors,main = paste0(st.uq.quality4plot[i],' - ',st.uq.class[j]),
colorkey = list(labels=list(labels = c('0','0.05','0.1','0.2','0.3','0.4','0.5'),at=c(0,0.05,0.1,0.2,0.3,0.4,0.5))),
scales=list(tck = c(1,0),
x=list(rot=45,cex=2,draw=T),#,draw=ifelse(i==1||i==4,F,T)),
y=list(cex=2,draw=T),#draw=ifelse(i==2||i==4,F,T)),
main=list(st.uq.quality4plot[i],cex=2)),
panel=function(...){             # for the points on the plot (Stars where p.adj <= 0.05)
panel.levelplot(...)
if(nrow(starIdx_nA)!=0){
grid.points(x= starIdx_nA$row,y=starIdx_nA$col, pch=p_symbol,gp=gpar(fill=pointFill))}
if(nrow(starIdx)!=0){
grid.points(x= starIdx$row,y=starIdx$col, pch=p_adj_symbol,gp=gpar(fill=pointFill))}
grid.points(x = 4.5 ,y = 1.00, pch=p_symbol,gp=gpar(fill=pointFill))
grid.points(x = 4.5 ,y = 1.60, pch=p_symbol,gp=gpar(fill=pointFill))
grid.points(x = 4.5 ,y = 1.00, pch=p_adj_symbol,gp=gpar(fill=pointFill))
grid.text('p',just='left',0.6,0.18)
grid.text(expression('p'[adj.]),just='left',0.60,0.08)
grid.text('< 0.05',just='left',0.71,0.18)
grid.text('< 0.05',just='left',0.71,0.08)
}
)
)
dev.off()
# panel.text(df$x, df$y, df$level, cex=0.5)
# print(st.uq.class[j])
# weekendSpringvsSummer = data.frame(case = length(st.uq.class),)
# new.p.nA.xtab['WeekendSpring',]['WeekendSummer'])
# new.p.nA.xtab['WeekendSpring',]['IntenseSummer'])
}
}
resListDBt[[i]]$P.adjusted[resListDBt[[i]]$comparisons=="hourly - weekly"]
resListDBt[[i]]$P[resListDBt[[i]]$comparisons=="hourly - weekly"]
# PlotLis_ord = PlotList[c(1,4,3,2)]
#
# png(filename = 'G:/h2k-data/Projects/CrowdWater/WP1/Paper/Figures/BonferroniHeatMap.png',width = 1000,height = 1000)
# c(PlotLis_ord[[1]],PlotLis_ord[[2]],PlotLis_ord[[3]],PlotLis_ord[[4]], x.same = NA, y.same = NA,
#   layout = NULL, merge.legends = FALSE, recursive = FALSE)
# dev.off()
#
#
# mergedPlots = c(PlotLis_ord[[1]],PlotLis_ord[[2]],PlotLis_ord[[3]],PlotLis_ord[[4]], x.same = NA, y.same = NA,
#   layout = NULL, merge.legends = FALSE, recursive = FALSE)
# update(mergedPlots,ylab.right = F)
# setEPS()
# postscript("G:/h2k-data/Projects/CrowdWater/WP1/Paper/Figures/BonferroniHeatMap.eps",width = 15,height = 15)
# mergedPlots
# dev.off()
#
#
# # Put the plots into one image
# PlotLis_ord = PlotList[c(1,4,3,2)]
# png(filename = 'G:/h2k-data/Projects/CrowdWater/WP1/Paper/Figures/BonferroniHeatMap.png',width = 1000,height = 1000)
# plot.new()
# par(mfrow=c(2,2), oma=c(2,0,2,0))
# print(PlotLis_ord[[1]], split=c(1, 1, 2, 2))
# print(PlotLis_ord[[2]], split=c(2, 1, 2, 2), newpage=FALSE)
# print(PlotLis_ord[[3]], split=c(1, 2, 2, 2), newpage=FALSE)
# print(PlotLis_ord[[4]], split=c(2, 2, 2, 2), newpage=FALSE)
# grid.text("a)", x = .1, y = .945, just = c("left", "bottom"), gp = gpar(cex=2))
# grid.text("b)", x = .6, y = .945, just = c("left", "bottom"), gp = gpar(cex=2))
# grid.text("c)", x = .1, y = .445, just = c("left", "bottom"), gp = gpar(cex=2))
# grid.text("d)", x = .6, y = .445, just = c("left", "bottom"), gp = gpar(cex=2))
# dev.off()
#
# c(PlotLis_ord[[1]],PlotLis_ord[[2]],PlotLis_ord[[3]],PlotLis_ord[[4]],layout=2:2)
# p1 = levelplot(p.nA.xtab)
# p2 = levelplot(p.nA.xtab)
# p3 = levelplot(p.nA.xtab)
# p4 = levelplot(p.nA.xtab)
# c(p1,p2,p3,p4,layout=2:2)
shiny::runApp()
locFile4Attempt = 'CW_Data.csv'
observeEvent(input$reloadAllCWdata,{
CWdataFull = Download_AllCWdata_from_API()
colnames(CWdataFull)[1]='Spot_ID'
write.csv(CWdataFull,file=paste0("CWdata/",locFile4Attempt),row.names = F)
js$refresh()
})
if(file.exists(paste0("CWdata/",locFile4Attempt))){
CWdataFull = read.csv(paste0("CWdata/",locFile4Attempt))
latestUpdate = CWdataFull$created_at[nrow(CWdataFull)]
newCWdata = Download_LatestCWdata_from_API(lastDate = latestUpdate)
if(!is.null(newCWdata)){
colnames(newCWdata)[1]='Spot_ID'
CWdataFull = rbind(CWdataFull,newCWdata)
write.csv(CWdataFull,file=paste0("CWdata/",locFile4Attempt),row.names = F)
}
}else{
CWdataFull = Download_AllCWdata_from_API()
colnames(CWdataFull)[1]='Spot_ID'
write.csv(CWdataFull,file=paste0("CWdata/",locFile4Attempt),row.names = F)
}
CWdata = CWdataFull # select all CW data
output$allRootIDs = unique(CWdata$ROOTID)
runApp()
shiny::runApp()
TS_LUT <<- data.frame(TSID = 471:476,TSnr = seq_along(471:476),TSInput=c("dry streambed","damp / wet streambed","isolated pools","trickling water","standing water","flowing"))
TS_LUT
source('G:/h2k-data/Projects/CrowdWater/App & Homepage/Homepage/DataDashboard/CrowdWaterDashboard/CW_API_Download.R', echo=TRUE)
source('G:/h2k-data/Projects/CrowdWater/App & Homepage/Homepage/DataDashboard/CrowdWaterDashboard/CW_API_Download.R', echo=TRUE)
runApp()
source('G:/h2k-data/Projects/CrowdWater/App & Homepage/Homepage/DataDashboard/CrowdWaterDashboard/CW_API_Download.R', echo=TRUE)
source('G:/h2k-data/Projects/CrowdWater/App & Homepage/Homepage/DataDashboard/CrowdWaterDashboard/CW_API_Download.R', echo=TRUE)
runApp()
